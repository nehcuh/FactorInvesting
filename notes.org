#+TITLE: 因子投资方法与实践 -- 笔记与代码
#+AUTHOR: 胡琛

* 因子投资基础

* 因子投资方法论
#+BEGIN_QUOTE
首先介绍如何使用排序法构建因子模拟组合并检验，它是一切的基础。
然后是使用不同的回归方法对多因子模型进行检验，这是核心。
之后进一步对因子暴露和因子收益率检验进行解读，因子投资中一个重要内容就是通过异象获取多因子模型无法解释的超额收益。
再然后是介绍不同的多因子模型方法。
跟着是多因子处理方式：1. 因子正交化 2. 广义矩估计
#+END_QUOTE

** 因子组合排序法
如何定量描述解释股票收益率的因子，需要用到实证资产定价和因子投资中一个重要的概念--因子模拟投资组合。
*** 因子模拟投资组合
1. 因子模拟投资组合是使用股票资产，围绕某个目标因子构建的投资组合
2. 投资组合需要满足以下条件
   - 该投资组合仅在目标因子上有大于 0 的暴露，在其他因子暴露为 0
   - 在所有满足条件一的投资组合中，该投资组合的特质性风险最小
3. 举例：下表中可以构建的围绕因子 A, 符合投资组合条件的组合可以是股票一与股票四等权重配置
   | 股票   | 因子A 暴露 | 因子 B 暴露 | 特质性风险 |
   |--------+------------+-------------+------------|
   | 股票一 |        0.8 |         0.4 |         1% |
   | 股票二 |        1.3 |         0.6 |         2% |
   | 股票三 |        0.6 |        -0.4 |         5% |
   | 股票四 |        1.2 |        -0.4 |         1% |
*** 排序法及其检验
构建因子的模拟组合前提是知道所有股票在该因子上的暴露，股票在某因子上 $i$ 上的暴露 $\beta_i$ 反映的是在
控制其他因子后，该目标因子的收益率变化对股票超额收益变化的影响程度。这意味着需要首先知道因子收益率才能计算
因子暴露。但是，之前讨论是需要有因子模拟组合后才能计算因子收益，因子暴露又是构建因子模拟组合的前提，由此，
构建因子模拟组合陷入矛盾。一种绕过矛盾的方案是通过排序法来构建因子组合。

以账面市值比(BM, book-to-market ratio, 市净率倒数)为例
1. 排序：首先确定股票池，将池中所有股票在截面上按照排序变量的取值高低从大到小 (或从小到大) 排序
2. 分组：按排序高低将全部股票分为 L 组 (按照惯例，一般取十分位)。最多排名最高的第一组股票，做空排名最低
   的最后一组股票，由此构建一个多空对冲的组合，该投资组合又被称为 **价差组合**。
3. 定期更新：个股在变量上并非取值不变，需要定期进行上述两个步骤，学术上称之为 **再平衡** ，一般再平衡的
   频率为一个月或一年。
上述检验方法称之为 **投资组合排序检验**

投资组合排序检验最重要的目的是检验因子预期收益率。理论上，因子预期收益率应该大于 0 (否则按照多因子模型，
对资产定价，该因子为 0，没有意义)，因此，检验关注的是根据样本数据计算出来的因子收益率，能否在给定的显著性
水平下拒绝因子收益率为 0 的假设。

令 $\{\lambda_t\}(t=1,2,\ldots,T)$ 表示因子收益率时间序列，则因子预期收益率的估计 $\hat{\lambda}$
以及其标准误差 $s.e.(\hat{\lambda})$ 分别为
\begin{aligned}
  \hat{\lambda} &= \frac{1}{T}\sum\limits_{t=1}^T\lambda_t\\
  s.e.(\hat{\lambda}) &= \frac{\mathbf{std}(\lambda_t)}{\sqrt{T}}
\end{aligned}
有了 $\hat{\lambda}$ 与 $s.e.(\hat{\lambda})$, 便可以在原假设 ($\lambda=0$) 进行 t-检验，计算 t-值。
\begin{equation}
  t = \frac{\hat{\lambda}}{s.e.(\hat{\lambda})}
\end{equation}
上式满足自由度为 $T-1$ 的 t 分布。根据 t-值和 t-分布 可以计算出 p 值，然后通过 t-value 和 p-value 就
能够在给定的显著性水平下接受或拒绝原假设。

以 BM 为例对全 A 股市场进行检验，检验采用截面方法，对应 09-30 的财务日期，取 06-30 的截面数据[fn:1][fn:2]
#+BEGIN_SRC python
import QUANTAXIS as QA
import pandas as pd
from functools import partial

# 全市场股票代码
code_list_1 = QA.QA_fetch_stock_list().index.tolist()

# 上市时间过滤
# 1. 这里用了一点小技巧，通过公司财报发布数量直接进行过滤
# 2. 公司财报真实数量按照所有财报中最大值可以确定
# 3. 取 2015/01/01 到 2019/09/26 截止的财务数据
# 4. 财报实际发布日期与对应的会计日期不一致, 一个简单的处理方式,
# 对所有的财报日期进行一个 shift, 这样, 基本可以保证对应的截面
# 财报都已经公布
df_finance = QA.QA_fetch_financial_report_adv(
    code=code_list_1, start="2014-09-30", end="2020-09-26").data
max_report_num = df_finance.groupby(level=1).apply(len).max()
filter_se = df_finance.groupby(level=1).apply(len) == max_report_num
code_list_2 = filter_se.loc[filter_se].index.tolist()

# 过滤后每股净资产
se_value = df_finance.loc[(slice(None), code_list_2), "netAssetsPerShare"]

# 股价获取
dates_list = se_value.index.levels[0].unique().map(
    str).str.slice(0, 10).tolist()
df_price = pd.DataFrame()
drop_codes = set()
for report_date in dates_list:
    real_trade_date = QA.QA_util_get_real_date(report_date)
    df_local = QA.QA_fetch_stock_day_adv(
        code=code_list_2, start=real_trade_date, end=real_trade_date).data
    df_price = df_price.append(df_local)
    if set(code_list_2).difference(set(df_local.index.remove_unused_levels().levels[1].unique())):
        drop_codes = drop_codes.union(set(code_list_2).difference(
            set(df_local.index.remove_unused_levels().levels[1].unique())))
code_list_3 = sorted(list(set(code_list_2).difference(drop_codes)))

df_tmp_1 = df_price.loc[(slice(None), code_list_3), "close"].unstack(level=1)
df_tmp_2 = se_value.loc[(slice(None), code_list_3)].unstack(level=1)
df_tmp_1.index = df_tmp_2.index

# 市净率
factor_bm = (df_tmp_2 / df_tmp_1).shift(1).dropna()

# 按照对应的 report_date 进行分位处理
bm_quantiles = factor_bm.apply(partial(pd.qcut, q=10, labels=False), axis=1)

# 获取市值，方便进行加权处理，注意： QA 默认在市值计算中都进行了前复权处理，复权不影响市值计算
df_market = pd.DataFrame()
for report_date in dates_list[1:]:  # 注意: 因子计算完毕, 第 1 期因子起始时间已经从 2015-3-31 开始
    real_trade_date = QA.QA_util_get_real_date(report_date)
    df_market = df_market.append(QA.QAAnalysis_block(
        code=code_list_3, start=real_trade_date, end=real_trade_date).market_value["mv"].unstack(level=1))

# 索引重新设置
df_market.index = bm_quantiles.index
df_weights = df_market.apply(lambda x: x/x.sum(), axis=1)

# 计算收益率, 同样需要 shift(1), 同时考虑到收益率计算是两期的差值计算得到
pct = df_tmp_1.pct_change().shift(-1).dropna()

# 合并所需的数据, 方便计算
se_1 = bm_quantiles.loc[pct.index].stack()
se_2 = df_weights.loc[pct.index].stack()
se_3 = pct.stack()
df = pd.concat([se_1.rename("quantiles"), se_2.rename(
    "weights"), se_3.rename("pct_change")], axis=1)
df["weighted_pct"] = df["weights"] * df["pct_change"]
pct_quantiles = df.groupby(level=0).apply(lambda x: x.groupby(
    "quantiles").apply(lambda y: y.weighted_pct.sum()))
#+END_SRC

*** 多重排序法
1. 双重排序
   #+BEGIN_QUOTE
将两个变量排序并构建因子模拟组合。考虑两个排序变量 X1 和 X2, 将股票按照这两个变量分别划分为
L1 和 L2 组，一共得到 L1xL2 个组合。双重排序时，如果对这两个变量分别独立对股票排序，称为
独立双重排序；如果这两个变量排序存在先后依存关系，称之为条件双重排序。
   #+END_QUOTE

2. 双重独立排序的做法
   | P11 | P12 | P13 | P14 | P15 |
   | P21 | P22 | P23 | P24 | P25 |
   | P31 | P32 | P33 | P34 | P35 |
   | P41 | P42 | P43 | P44 | P45 |
   | P51 | P52 | P53 | P54 | P55 |
   - 使用两个排序变量分别独立将股票划分为 5 组，即 $L_1=L_2=5$, 两两交集得到 25 个投资组合
   - 对这 25 个组合可以围绕给定的变量构建因子模拟投资组合
   - 令 $R_{ij},t$ 表示投资组合 $P_{ij}$ 第 $t$ 期的收益率，则 $X_1$ 因子第 $t$ 期收益率
     $\lambda_{X_1 t}$ 为：
     \begin{equation}
       \lambda_{X_1 t} = \frac{1}{L_2}\sum\limits_{i=1}^{L_2}R_{L_1 i,t} - \frac{1}{L_2}\sum\limits_{i=1}^{L_2}R_{1i,t}
     \end{equation}
   - 同样地，围绕变量 $X_2$ 构建投资组合，因子第 $t$ 期收益率 $\lambda_{X_2 t}$ 如下：
     \begin{equation}
       \lambda_{X_2 t} = \frac{1}{L_1}\sum\limits_{i=1}^{L_1}R_{L_2 i,t} - \frac{1}{L_1}\sum\limits_{i=1}^{L_1}R_{i1,t}
     \end{equation}

3. 双重排序法使用场景
   #+BEGIN_QUOTE
在学术界针对美股市场异象研究中，双重排序法用的比较多。为了检验一个新的异象变量是否可以获得超额收益，学
者们往往用它和已有的因子变量进行双重排序，从而排除已有因子的影响。在进行分析时，学者们除了关心异象收益
率之外，还关心在已有因子变量的每组内，该异象变量能否区分股票收益率截面差异。对应 $X_1$ 和 $X_2$ 两个变量，
为了检验能否通过 $X_1$ 构建异象，应考察在每个 $X_2$ 分组内，根据 $X_1$ 划分的 $L_1$ 的分组内，
最高与最低分组的收益率差异是否显著。
   #+END_QUOTE

4. 条件双重排序的做法
   - 先用 $X_1$ 排序将全部股票划分为 $L_1$ 组，再对每个分组利用 $X_2$ 进行排序，划分为 $L_2$ 组，
     最后得到 $L_1\times L_2$ 个分组
   - 假设 $X_1$ 和 $X_2$ 分别是第一、第二排序变量，则围绕 $X_2$ 构建因子收益率与独立双重排序的公式
     一样
   - 此外，另外一种方法，仍以 $X_1$ 和 $X_2$ 为第一、第二变量，在这种方法中，将全部 $L_1$ 个 $X_2$
     排名最高的组，即 $P_{iL_2}(i=1,2,\ldots,L_1)$ 以及 $L_1$ 个 $X_2$ 排名最低的组，即
     $P_{i1}(i=1,2,\ldots,L_1)$ 分别取并集
     \begin{aligned}
       P_{L_2}^{top} &= P_{1L_2} \cup P{2L_2} \cup \ldots P_{L_1L_2}\\
       P_{L_2}^{bottom} &= P_{11} \cup P{21} \cup \ldots P_{L_11}\\
     \end{aligned}
     将 $P_{L_2}^{top}$ 中全部股票按照市值加权或等权重配置，构成变量 $X_2$ 的多头；将 $P_{L_2}^{bottom}$
     按同样方式构成 $X_2$ 空头，可以构建围绕 $X_2$ 的因子收益率
     \begin{equation}
       \lambda_{{X_{2}t}} = R_{L_{2}}^{top} - R_{L_{2}}^{top}
     \end{equation}

5. 独立双重排序与条件双重排序比较
   - 独立双重排序可能导致某个分组股票很少；条件双重则保证了每组内都有足够股票
   - 控制某个变量来观察另一个变量对收益率的影响，条件双重排序更为合适，不过学术界用独立双重排序比较多
** 多因子模型的回归检验
** 因子暴露与因子收益率
** 异象检验
** 多因子模型比较
** 因子正交化
** 广义矩阵分析
** 研究方法建议

* Footnotes

[fn:2] 考虑到数据获取难易与收费情况，这里主要使用两个数据源，quantaxis(通达信的数据) 和掘金量化

[fn:1] 譬如，在 2020-09-30 对应的日期，上一期财报原则上都应该公布了，此时，在 09-30 这个截面上，取 06-30 的
财务数据，是比较合理的选择
